// ReSharper disable ReturnValueOfPureMethodIsNotUsed
// ReSharper disable CheckNamespace
// ReSharper disable UnusedVariable
// ReSharper disable UnusedParameter.Global
// ReSharper disable ConvertToConstant.Local
// ReSharper disable UnusedMember.Local
// ReSharper disable RedundantBaseQualifier
// ReSharper disable RedundantThisQualifier
// ReSharper disable EqualExpressionComparison
using System;
#pragma warning disable 659

public enum E { C }
public interface I { void InstanceMethod(); }

public struct S : I {
  public void InstanceMethod() { }
  private static void StaticMethod() { }

  public override int GetHashCode() {
    var box = base.|GetHashCode|(0)(); // boxing

    Action f = ||InstanceMethod|(1)|(2), g = |StaticMethod|(3);
    Func<int>
      g1 = base.||GetHashCode|(4)|(5),
      g2 = ||GetHashCode|(6)|(7);

    return |new|(8)[] {
      base.|ToString|(9)(),
      |ToString|(10)()
    }.Length;
  }
}

public static class Extensions {
  public static void ExtensionMethod(this I i) { }
}

public static class A {
  private static void ConcreteTypesWithoutOverrides(S s, E e, S? n) {
    var str = "aa" |+|(11) s + 'a';
    object o1 = |s|(12), o2 = |n|(13);
    ValueType v1 = |s|(14), v2 = |n|(15);
    Enum y1 = |e|(16), y2 = |(E?) e|(17);
    I i1 = |s|(18), i2 = |(S?) s|(19);

    Action f = s.||InstanceMethod|(20)|(21);
    Func<int> g = e.||GetHashCode|(22)|(23);

    |s|(24).ExtensionMethod();
    |n|(25).ExtensionMethod();
    s.|Equals|(26)(null);
    n.|Equals|(27)(null);
    s.|GetType|(28)();
    n.GetValueOrDefault();

    e.|ToString|(29)();
    e.|GetHashCode|(30)(); // fixed in CoreCLR
    e.|Equals|(31)(|e|(32));

    // no boxing
    s.InstanceMethod();
    n?.InstanceMethod();
    s.GetHashCode();
  }

  private static void Struct<TStruct>(TStruct s) where TStruct : struct, I {
    object o1 = |s|(33), o2 = |(TStruct?) s|(34);
    ValueType v1 = |s|(35), v2 = |(TStruct?) s|(36);
    I i1 = |s|(37), i2 = |(TStruct?) s|(38);

    // always
    Action f = s.||InstanceMethod|(39)|(40);
    |s|(41).ExtensionMethod();
    s.|GetType|(42)();

    // possible
    s.|GetHashCode|(43)();
    s.|ToString|(44)();
    s.|Equals|(45)(null);

    // no boxing
    s.InstanceMethod();
  }

  private static void Unmanaged<TUnmanaged>(TUnmanaged u) where TUnmanaged : unmanaged, I {
    object o1 = |u|(46), o2 = |(TUnmanaged?) u|(47);
    ValueType v1 = |u|(48), v2 = |(TUnmanaged?) u|(49);
    I i1 = |u|(50), i2 = |(TUnmanaged?) u|(51);

    // always
    Action f = u.||InstanceMethod|(52)|(53);
    |u|(54).ExtensionMethod();
    u.|GetType|(55)();

    // possible
    u.|GetHashCode|(56)();
    u.|ToString|(57)();
    u.|Equals|(58)(null);

    // no boxing
    u.InstanceMethod();
  }

  private static void Nullable<TNullable>(TNullable? n) where TNullable : struct, I {
    object o1 = |n|(59);
    ValueType v1 = |n|(60);
    I i1 = |n|(61);

    // always
    Func<int> f = n.||GetHashCode|(62)|(63);
    |n|(64).ExtensionMethod(); // boxing!
    n.|GetType|(65)();

    // possible boxing INSIDE Nullable<T>
    n.GetHashCode();
    n.ToString();
    n.Equals(null);

    // no boxing
    n?.InstanceMethod();
  }

  private static void Reference<TReferenceType>(TReferenceType r) where TReferenceType : class, I, new() {
    object o1 = r;
    I i1 = r;

    Action f = r.|InstanceMethod|(66);
    r.ExtensionMethod();
    r.GetType();

    // no boxing
    r.GetHashCode();
    r.ToString();
    r.Equals(null);

    // no boxing
    r.InstanceMethod();
  }

  private static void Unconstrained<TUnconstrained>(TUnconstrained u) where TUnconstrained : I, new() {
    object o1 = |u|(67);
    I i1 = |u|(68);

    Action f = u.||InstanceMethod|(69)|(70);
    |u|(71).ExtensionMethod();
    u.|GetType|(72)();

    // possible
    u.GetHashCode();
    u.ToString();
    u.Equals(null);

    // no boxing
    u.InstanceMethod();
  }
}
---------------------------------------------------------
(0): ReSharper HeapView Boxing: Boxing allocation: inherited 'System.Object' virtual method call on value type instance
(1): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'S' instance method to 'Action' delegate type
(2): ReSharper HeapView Allocation: Delegate allocation: from method group
(3): ReSharper HeapView Allocation: Delegate allocation: from method group
(4): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'S' instance method to 'Func<int>' delegate type
(5): ReSharper HeapView Allocation: Delegate allocation: from method group
(6): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'S' instance method to 'Func<int>' delegate type
(7): ReSharper HeapView Allocation: Delegate allocation: from method group
(8): ReSharper HeapView Allocation: Object allocation: array creation
(9): ReSharper HeapView Boxing: Boxing allocation: inherited 'System.Object' virtual method call on value type instance
(10): ReSharper HeapView Boxing: Boxing allocation: inherited 'System.Object' virtual method call on value type instance
(11): ReSharper HeapView Allocation: Object allocation: string concatenation (3 operands)
(12): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S' to 'object' requires boxing of the value type
(13): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S?' to 'object' requires boxing of the value type
(14): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S' to 'ValueType' requires boxing of the value type
(15): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S?' to 'ValueType' requires boxing of the value type
(16): ReSharper HeapView Boxing: Boxing allocation: conversion from 'E' to 'Enum' requires boxing of the value type
(17): ReSharper HeapView Boxing: Boxing allocation: conversion from 'E?' to 'Enum' requires boxing of the value type
(18): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S' to 'I' requires boxing of the value type
(19): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S?' to 'I' requires boxing of the value type
(20): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'S' instance method to 'Action' delegate type
(21): ReSharper HeapView Allocation: Delegate allocation: from method group
(22): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'E' instance method to 'Func<int>' delegate type
(23): ReSharper HeapView Allocation: Delegate allocation: from method group
(24): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S' to 'I' requires boxing of the value type
(25): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S?' to 'I' requires boxing of the value type
(26): ReSharper HeapView Boxing: Boxing allocation: inherited 'System.Object' virtual method call on value type instance
(27): ReSharper HeapView Boxing: Boxing allocation: inherited 'System.Object' virtual method call on value type instance
(28): ReSharper HeapView Boxing: Boxing allocation: special 'Object.GetType()' method invocation over the value type instance
(29): ReSharper HeapView Boxing: Boxing allocation: inherited 'System.Object' virtual method call on value type instance
(30): ReSharper HeapView Boxing: Boxing allocation: inherited 'System.Object' virtual method call on value type instance
(31): ReSharper HeapView Boxing: Boxing allocation: inherited 'System.Object' virtual method call on value type instance
(32): ReSharper HeapView Boxing: Boxing allocation: conversion from 'E' to 'object' requires boxing of the value type
(33): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct' to 'object' requires boxing of the value type
(34): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct?' to 'object' requires boxing of the value type
(35): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct' to 'ValueType' requires boxing of the value type
(36): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct?' to 'ValueType' requires boxing of the value type
(37): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct' to 'I' requires boxing of the value type
(38): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct?' to 'I' requires boxing of the value type
(39): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'TStruct' instance method to 'Action' delegate type
(40): ReSharper HeapView Allocation: Delegate allocation: from method group
(41): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct' to 'I' requires boxing of the value type
(42): ReSharper HeapView Boxing: Boxing allocation: special 'Object.GetType()' method invocation over the value type instance
(43): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'GetHashCode' virtual method call over the value type instance if the type argument for 'TStruct' type parameter do no overrides '{0}' virtual method
(44): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ToString' virtual method call over the value type instance if the type argument for 'TStruct' type parameter do no overrides '{0}' virtual method
(45): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'Equals' virtual method call over the value type instance if the type argument for 'TStruct' type parameter do no overrides '{0}' virtual method
(46): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged' to 'object' requires boxing of the value type
(47): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged?' to 'object' requires boxing of the value type
(48): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged' to 'ValueType' requires boxing of the value type
(49): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged?' to 'ValueType' requires boxing of the value type
(50): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged' to 'I' requires boxing of the value type
(51): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged?' to 'I' requires boxing of the value type
(52): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'TUnmanaged' instance method to 'Action' delegate type
(53): ReSharper HeapView Allocation: Delegate allocation: from method group
(54): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged' to 'I' requires boxing of the value type
(55): ReSharper HeapView Boxing: Boxing allocation: special 'Object.GetType()' method invocation over the value type instance
(56): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'GetHashCode' virtual method call over the value type instance if the type argument for 'TUnmanaged' type parameter do no overrides '{0}' virtual method
(57): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ToString' virtual method call over the value type instance if the type argument for 'TUnmanaged' type parameter do no overrides '{0}' virtual method
(58): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'Equals' virtual method call over the value type instance if the type argument for 'TUnmanaged' type parameter do no overrides '{0}' virtual method
(59): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TNullable?' to 'object' requires boxing of the value type
(60): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TNullable?' to 'ValueType' requires boxing of the value type
(61): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TNullable?' to 'I' requires boxing of the value type
(62): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'TNullable?' instance method to 'Func<int>' delegate type
(63): ReSharper HeapView Allocation: Delegate allocation: from method group
(64): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TNullable?' to 'I' requires boxing of the value type
(65): ReSharper HeapView Boxing: Boxing allocation: special 'Object.GetType()' method invocation over the value type instance
(66): ReSharper HeapView Allocation: Delegate allocation: from method group
(67): ReSharper HeapView Boxing: Possible boxing allocation: conversion from 'TUnconstrained' to 'object' possibly requires boxing of the value type
(68): ReSharper HeapView Boxing: Possible boxing allocation: conversion from 'TUnconstrained' to 'I' possibly requires boxing of the value type
(69): ReSharper HeapView Allocation: Delegate allocation: from method group
(70): ReSharper HeapView Boxing: Possible boxing allocation: conversion of value type 'TUnconstrained' instance method to 'Action' delegate type
(71): ReSharper HeapView Boxing: Possible boxing allocation: conversion from 'TUnconstrained' to 'I' possibly requires boxing of the value type
(72): ReSharper HeapView Boxing: Possible boxing allocation: special 'Object.GetType()' method may be invoked over the value type instance if 'TUnconstrained' type parameter will be substituted with the value type
