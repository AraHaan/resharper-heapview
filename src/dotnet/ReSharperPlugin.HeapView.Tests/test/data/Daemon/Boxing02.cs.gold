// ReSharper disable ReturnValueOfPureMethodIsNotUsed
// ReSharper disable CheckNamespace
// ReSharper disable UnusedVariable
// ReSharper disable UnusedParameter.Global
// ReSharper disable ConvertToConstant.Local
// ReSharper disable UnusedMember.Local
// ReSharper disable RedundantBaseQualifier
// ReSharper disable RedundantThisQualifier
// ReSharper disable EqualExpressionComparison
using System;
#pragma warning disable 659

public enum E { C }
public interface I { void InstanceMethod(); }

public struct S : I {
  public void InstanceMethod() { }
  private static void StaticMethod() { }

  public override int GetHashCode() {
    var box = base.|GetHashCode|(0)(); // boxing

    Action f = ||InstanceMethod|(1)|(2), g = StaticMethod;
    Func<int>
      g1 = |base|(3).|GetHashCode|(4),
      g2 = ||GetHashCode|(5)|(6);

    return |new|(7)[] {
      base.|ToString|(8)(),
      |ToString|(9)()
    }.Length;
  }
}

public static class Extensions {
  public static void ExtensionMethod(this I i) { }
}

public static class A {
  private static void ConcreteTypesWithoutOverrides(S s, E e, S? n) {
    var str = "aa" |+|(10) s + 'a';
    object o1 = |s|(11), o2 = |n|(12);
    ValueType v1 = |s|(13), v2 = |n|(14);
    Enum y1 = |e|(15), y2 = |(E?) e|(16);
    I i1 = |s|(17), i2 = |(S?) s|(18);

    Action f = |s|(19).|InstanceMethod|(20);
    Func<int> g = |e|(21).|GetHashCode|(22);

    |s|(23).ExtensionMethod();
    |n|(24).ExtensionMethod();
    s.|Equals|(25)(null);
    n.|Equals|(26)(null);
    s.|GetType|(27)();
    n.GetValueOrDefault();

    e.|ToString|(28)();
    e.|GetHashCode|(29)(); // fixed in CoreCLR
    e.|Equals|(30)(|e|(31));

    // no boxing
    s.InstanceMethod();
    n?.InstanceMethod();
    s.GetHashCode();
  }

  private static void Struct<TStruct>(TStruct s) where TStruct : struct, I {
    object o1 = |s|(32), o2 = |(TStruct?) s|(33);
    ValueType v1 = |s|(34), v2 = |(TStruct?) s|(35);
    I i1 = |s|(36), i2 = |(TStruct?) s|(37);

    // always
    Action f = |s|(38).|InstanceMethod|(39);
    |s|(40).ExtensionMethod();
    s.|GetType|(41)();

    // possible
    s.|GetHashCode|(42)();
    s.|ToString|(43)();
    s.|Equals|(44)(null);

    // no boxing
    s.InstanceMethod();
  }

  private static void Unmanaged<TUnmanaged>(TUnmanaged u) where TUnmanaged : unmanaged, I {
    object o1 = |u|(45), o2 = |(TUnmanaged?) u|(46);
    ValueType v1 = |u|(47), v2 = |(TUnmanaged?) u|(48);
    I i1 = |u|(49), i2 = |(TUnmanaged?) u|(50);

    // always
    Action f = |u|(51).|InstanceMethod|(52);
    |u|(53).ExtensionMethod();
    u.|GetType|(54)();

    // possible
    u.|GetHashCode|(55)();
    u.|ToString|(56)();
    u.|Equals|(57)(null);

    // no boxing
    u.InstanceMethod();
  }

  private static void Nullable<TNullable>(TNullable? n) where TNullable : struct, I {
    object o1 = |n|(58);
    ValueType v1 = |n|(59);
    I i1 = |n|(60);

    // always
    Func<int> f = |n|(61).|GetHashCode|(62);
    |n|(63).ExtensionMethod(); // boxing!
    n.|GetType|(64)();

    // possible boxing INSIDE Nullable<T>
    n.|GetHashCode|(65)();
    n.|ToString|(66)();
    n.|Equals|(67)(null);

    // no boxing
    n?.InstanceMethod();
  }

  private static void Reference<TReferenceType>(TReferenceType r) where TReferenceType : class, I, new() {
    object o1 = r;
    I i1 = r;

    Action f = r.|InstanceMethod|(68);
    r.ExtensionMethod();
    r.GetType();

    // no boxing
    r.GetHashCode();
    r.ToString();
    r.Equals(null);

    // no boxing
    r.InstanceMethod();
  }

  private static void Unconstrained<TUnconstrained>(TUnconstrained u) where TUnconstrained : I, new() {
    object o1 = |u|(69);
    I i1 = |u|(70);

    Action f = |u|(71).|InstanceMethod|(72);
    |u|(73).ExtensionMethod();
    u.|GetType|(74)();

    // possible
    u.|GetHashCode|(75)();
    u.|ToString|(76)();
    u.|Equals|(77)(null);

    // no boxing
    u.InstanceMethod();
  }
}
---------------------------------------------------------
(0):<overlapped> ReSharper HeapView Boxing: Boxing allocation: inherited 'ValueType.GetHashCode()' virtual method invocation over the value type instance
(1):<overlapped> ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'S' instance method to 'Action' delegate type
(2): ReSharper HeapView Allocation: Delegate allocation: new 'Action' instance creation
(3): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'S' instance method to 'Func<int>' delegate type
(4):<overlapped> ReSharper HeapView Allocation: Delegate allocation: new 'Func<int>' instance creation
(5):<overlapped> ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'S' instance method to 'Func<int>' delegate type
(6): ReSharper HeapView Allocation: Delegate allocation: new 'Func<int>' instance creation
(7): ReSharper HeapView Allocation: Object allocation: new 'string[]' array instance creation
(8): ReSharper HeapView Boxing: Boxing allocation: inherited 'ValueType.ToString()' virtual method invocation over the value type instance
(9): ReSharper HeapView Boxing: Boxing allocation: inherited 'ValueType.ToString()' virtual method invocation over the value type instance
(10): ReSharper HeapView Allocation: Object allocation: string concatenation (3 operands)
(11): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S' to 'object' requires boxing of the value type
(12): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S?' to 'object' requires boxing of the value type
(13): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S' to 'ValueType' requires boxing of the value type
(14): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S?' to 'ValueType' requires boxing of the value type
(15): ReSharper HeapView Boxing: Boxing allocation: conversion from 'E' to 'Enum' requires boxing of the value type
(16): ReSharper HeapView Boxing: Boxing allocation: conversion from 'E?' to 'Enum' requires boxing of the value type
(17): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S' to 'I' requires boxing of the value type
(18): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S?' to 'I' requires boxing of the value type
(19): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'S' instance method to 'Action' delegate type
(20): ReSharper HeapView Allocation: Delegate allocation: new 'Action' instance creation
(21): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'E' instance method to 'Func<int>' delegate type
(22): ReSharper HeapView Allocation: Delegate allocation: new 'Func<int>' instance creation
(23): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S' to 'I' requires boxing of the value type
(24): ReSharper HeapView Boxing: Boxing allocation: conversion from 'S?' to 'I' requires boxing of the value type
(25): ReSharper HeapView Boxing: Boxing allocation: inherited 'ValueType.Equals()' virtual method invocation over the value type instance
(26): ReSharper HeapView Boxing: Boxing allocation: inherited 'ValueType.Equals()' virtual method invocation over the value type instance
(27): ReSharper HeapView Boxing: Boxing allocation: special 'Object.GetType()' method invocation over the value type instance
(28): ReSharper HeapView Boxing: Boxing allocation: inherited 'Enum.ToString()' virtual method invocation over the value type instance
(29): ReSharper HeapView Boxing: Boxing allocation: inherited 'Enum.GetHashCode()' virtual method invocation over the value type instance
(30): ReSharper HeapView Boxing: Boxing allocation: inherited 'Enum.Equals()' virtual method invocation over the value type instance
(31): ReSharper HeapView Boxing: Boxing allocation: conversion from 'E' to 'object' requires boxing of the value type
(32): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct' to 'object' requires boxing of the value type
(33): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct?' to 'object' requires boxing of the value type
(34): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct' to 'ValueType' requires boxing of the value type
(35): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct?' to 'ValueType' requires boxing of the value type
(36): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct' to 'I' requires boxing of the value type
(37): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct?' to 'I' requires boxing of the value type
(38): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'TStruct' instance method to 'Action' delegate type
(39): ReSharper HeapView Allocation: Delegate allocation: new 'Action' instance creation
(40): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TStruct' to 'I' requires boxing of the value type
(41): ReSharper HeapView Boxing: Boxing allocation: special 'Object.GetType()' method invocation over the value type instance
(42): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ValueType.GetHashCode()' virtual method invocation over the value type instance if 'TStruct' type parameter will be substituted with the value type that do not overrides 'GetHashCode' virtual method
(43): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ValueType.ToString()' virtual method invocation over the value type instance if 'TStruct' type parameter will be substituted with the value type that do not overrides 'ToString' virtual method
(44): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ValueType.Equals()' virtual method invocation over the value type instance if 'TStruct' type parameter will be substituted with the value type that do not overrides 'Equals' virtual method
(45): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged' to 'object' requires boxing of the value type
(46): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged?' to 'object' requires boxing of the value type
(47): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged' to 'ValueType' requires boxing of the value type
(48): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged?' to 'ValueType' requires boxing of the value type
(49): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged' to 'I' requires boxing of the value type
(50): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged?' to 'I' requires boxing of the value type
(51): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'TUnmanaged' instance method to 'Action' delegate type
(52): ReSharper HeapView Allocation: Delegate allocation: new 'Action' instance creation
(53): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TUnmanaged' to 'I' requires boxing of the value type
(54): ReSharper HeapView Boxing: Boxing allocation: special 'Object.GetType()' method invocation over the value type instance
(55): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ValueType.GetHashCode()' virtual method invocation over the value type instance if 'TUnmanaged' type parameter will be substituted with the value type that do not overrides 'GetHashCode' virtual method
(56): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ValueType.ToString()' virtual method invocation over the value type instance if 'TUnmanaged' type parameter will be substituted with the value type that do not overrides 'ToString' virtual method
(57): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ValueType.Equals()' virtual method invocation over the value type instance if 'TUnmanaged' type parameter will be substituted with the value type that do not overrides 'Equals' virtual method
(58): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TNullable?' to 'object' requires boxing of the value type
(59): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TNullable?' to 'ValueType' requires boxing of the value type
(60): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TNullable?' to 'I' requires boxing of the value type
(61): ReSharper HeapView Boxing: Boxing allocation: conversion of value type 'TNullable?' instance method to 'Func<int>' delegate type
(62): ReSharper HeapView Allocation: Delegate allocation: new 'Func<int>' instance creation
(63): ReSharper HeapView Boxing: Boxing allocation: conversion from 'TNullable?' to 'I' requires boxing of the value type
(64): ReSharper HeapView Boxing: Boxing allocation: special 'Object.GetType()' method invocation over the value type instance
(65): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ValueType.GetHashCode()' virtual method invocation over the value type instance if 'TNullable' type parameter will be substituted with the value type that do not overrides 'GetHashCode' virtual method
(66): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ValueType.ToString()' virtual method invocation over the value type instance if 'TNullable' type parameter will be substituted with the value type that do not overrides 'ToString' virtual method
(67): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'ValueType.Equals()' virtual method invocation over the value type instance if 'TNullable' type parameter will be substituted with the value type that do not overrides 'Equals' virtual method
(68): ReSharper HeapView Allocation: Delegate allocation: new 'Action' instance creation
(69): ReSharper HeapView Boxing: Possible boxing allocation: conversion from 'TUnconstrained' to 'object' possibly requires boxing of the value type
(70): ReSharper HeapView Boxing: Possible boxing allocation: conversion from 'TUnconstrained' to 'I' possibly requires boxing of the value type
(71): ReSharper HeapView Boxing: Possible boxing allocation: conversion of value type 'TUnconstrained' instance method to 'Action' delegate type if 'TUnconstrained' type parameter will be substituted with the value type
(72): ReSharper HeapView Allocation: Delegate allocation: new 'Action' instance creation
(73): ReSharper HeapView Boxing: Possible boxing allocation: conversion from 'TUnconstrained' to 'I' possibly requires boxing of the value type
(74): ReSharper HeapView Boxing: Possible boxing allocation: special 'Object.GetType()' method may be invoked over the value type instance if 'TUnconstrained' type parameter will be substituted with the value type
(75): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'Object.GetHashCode()' virtual method invocation over the value type instance if 'TUnconstrained' type parameter will be substituted with the value type that do not overrides 'GetHashCode' virtual method
(76): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'Object.ToString()' virtual method invocation over the value type instance if 'TUnconstrained' type parameter will be substituted with the value type that do not overrides 'ToString' virtual method
(77): ReSharper HeapView Boxing: Possible boxing allocation: inherited 'Object.Equals()' virtual method invocation over the value type instance if 'TUnconstrained' type parameter will be substituted with the value type that do not overrides 'Equals' virtual method
