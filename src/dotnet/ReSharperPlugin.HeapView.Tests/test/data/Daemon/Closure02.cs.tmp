using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

// ReSharper disable TooWideLocalVariableScope
// ReSharper disable UnusedVariable
// ReSharper disable UnusedAutoPropertyAccessor.Local
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedParameter.Local
// ReSharper disable UnusedMember.Local
// ReSharper disable MemberCanBeMadeStatic.Local
// ReSharper disable ConvertToLambdaExpression

class Closures
{
  public void M2()
  {
    |var i|(0) = I;
    var xs = XS;
    var t1 = from x in xs
             |select|(1) i + 123; // closure
    var t2 = from x in xs
             select x + 123; // nothing
    var t3 = from x in xs
             from y |in|(2) xs // closure
             |select|(3) i;    // closure
    var t4 = from x in xs
             from y in XS  // nothing
             select y + x; // nothing
    var t5 = from x in xs
             from |y|(4) in XS // anonymous type
             from z in YS // nothing
             select x + y + z;
    var t6 = from x in xs
             |let|(5) |y|(6) = 123 + i  // anonymous + closure
             from z in XS // nothing
             select x + y + z; // nothing
    var t7 = from x in xs
             from |y|(7) in XS // anonymous type
             where x > 0  // nothing
             select x + y; // nothing
    var t8 = from x in xs
             from |y|(8) in XS // anonymous type
             from |z|(9) in YS // anonymous type
             from w in YS
             select x + y + z;
  }
  
  public void M3()
  {
    |var i|(10) = I;
    var t1 = from x in XS
             from |y|(11) in XS // anonymous type
             from |z|(12) in XS // anonymous type
             where x > 0
             select x + z;
    var t2 = from x in XS
             from y |in|(13) YS.|Concat|(14)(t1)
             select x into y
             |select|(15) y + i;
    var t3 = from x in XS
             group x |by|(16) x / 10 + i;
    var t4 = from x in XS
             |group|(17) x + i by x / 10;
    var t5 = from x in XS
             group x by x / 10 into g
             |select|(18) g.Key + i;
    var t6 = from x in XS
             join y in YS |on|(19) x + i |equals|(20) y + i
             |select|(21) x + y + i;
    var t7 = from x in XS
             join y in YS |on|(22) x + i equals y
             into z select x;
  
    var t8 = from x in XS select (
               from y in YS select y);
    var t9 = from x in XS |select|(23) (
               from y in YS.|Concat|(24)(t7)
               |select|(25) y + x + 123);
  }

  public void M4()
  {
    |int i|(26) = I, j = I;
    F(() |=>|(27) M() + X);
    F(() |=>|(28) M() + X + i);
    F(() |=>|(29) X + j);
  }

  public void M5()
  {
    |var i|(30) = I;
    F(() |=>|(31) i);

    {
      |var j|(32) = I;
      F(() |=>|(33) j);
    }
  }

  public void M6()
  {
    |var i|(34) = I;
    F(() |=>|(35) i);

    var j = I;
    F(() |=>|(36) j);
  }

  public void M7()
  {
    F(() |=>|(37)
    {
      M();
      |var i|(38) = I;
      F(() |=>|(39) i);
    });
  }

  public void M8(bool b)
  {
    |int a|(40);
    Console.WriteLine();
    if (b)
    {
      a = I;
      F(() |=>|(41) a);
      F(() |=>|(42) a);
    }
  }

  public void M9(bool t)
  {
    if (t)
    {
      |var a|(43) = I;
      F(() |=>|(44) a);
      F(() |=>|(45) a);
    }
    else
    {
      int z = I, b = I;
      F(() |=>|(46) b);
      F(() |=>|(47) b);
    }
  }

  public void M10(bool t)
  {
    if (t)
    {
      |var a|(48) = I;
      F(() |=>|(49) a);

      {
        |var c|(50) = I;
        F(() |=>|(51) a + c);

        var d = I;
        F(() |=>|(52) a + d);
      }
    }
    else
    {
      |var b|(53) = I;
      F(() |=>|(54) b);
      F(() |=>|(55) b);
    }
  }

  public void M11(int |arg|(56))
  {
    F(() |=>|(57)
    {
      F(|delegate|(58)(|int u|(59))
      {
        F(t |=>|(60) arg + t + u);
      });
    });
  }

  public void M12()
  {
    |var i|(61) = I;
    {
      |var j|(62) = I;
      {
        F(() |=>|(63)
        {
          M();
          return i + j;
        });
      }
    }
  }

  public void M13()
  {
    F(() |=>|(64)
    {
      F(() |=>|(65)
      {
        M();
        M();
      });
    });
  }

  public void M14<T>()
  {
    F(() |=>|(66) { });

    var xs = from x in XS
             |where|(67) x > 0
             |group|(68) x + 1 |by|(69) x + 2
             into x // should not be highlighted
             join |y|(70) in YS |on|(71) x.Key |equals|(72) y
             |let|(73) |t|(74) = 1
             |select|(75) y + t;
  }

  public void M15(int |arg|(76))
  {
    var y = F(() |=>|(77) X + arg);
    F(z |=>|(78) y);
  }

  public Action M16
  {
    get
    {
      return () |=>|(79) {
        var x = X;
      };
    }
    |set|(80)
    {
      F(() |=>|(81) value);
    }
  }

  public Action this[||int i|(82)|(83)]
  {
    get
    {
      return () |=>|(84)
        F(() |=>|(85) X + i);
    }
    set
    {
      var y = F(() |=>|(86) X + i);
      F(z |=>|(87) y);
    }
  }

  private Action<int>
    f = |x|(88) =>
    {

      F(() |=>|(89) x);
    },
    g = |x|(90) =>
    {
      F(() |=>|(91) x);
    };

  private Action<int, int, int>
    tt = (x, |y|(92), z) =>
    {
      F(() |=>|(93) y);
    };

  private IEnumerable<int> xsss = from x in Enumerable.Range(0, 100)
                                  where x < 0
                                  select F(() |=>|(94) x);

  public void M17(int |arg|(95))
  {
    Expression<Func<int, int>> e = x |=>|(96) x;

    var xs = Enumerable.Range(0, 10).|AsQueryable|(97)();
    var ys = from x in xs
             |where|(98) x > 0
             |select|(99) x + 1;

    Expression<Func<int>> f = () |=>|(100) arg;
    Expression<Action<int>> g = |t|(101) |=>|(102) F(() |=>|(103) t + arg);
    Expression<Func<int, int>> u = t |=>|(104) 1;
  }

  private static int I { get; set; }
  private int X { get; set; }
  private static List<int> XS { get; set; }
  private static List<int> YS { get; set; }
  private int M() { return 0; }
  private static void F(Action f) { }
  private static int F<T>(Func<T> f) { return 0; }
  private static void F(Action<int> f) { }
  private static void F(Func<int, int> f) { }
}
---------------------------------------------------------
(0): ReSharper HeapView Allocation: Closure allocation: 'i', 'xs' variables
(1): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(2): ReSharper HeapView Allocation: Delegate allocation: capture of 'xs' variable
(3): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(4): ReSharper HeapView Allocation: Object allocation: transparent identifier anonymous type instantiation
(5): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(6): ReSharper HeapView Allocation: Object allocation: transparent identifier anonymous type instantiation
(7): ReSharper HeapView Allocation: Object allocation: transparent identifier anonymous type instantiation
(8): ReSharper HeapView Allocation: Object allocation: transparent identifier anonymous type instantiation
(9): ReSharper HeapView Allocation: Object allocation: transparent identifier anonymous type instantiation
(10): ReSharper HeapView Allocation: Closure allocation: 'i', 't1', 't7' variables
(11): ReSharper HeapView Allocation: Object allocation: transparent identifier anonymous type instantiation
(12): ReSharper HeapView Allocation: Object allocation: transparent identifier anonymous type instantiation
(13): ReSharper HeapView Allocation: Delegate allocation: capture of 't1' variable
(14): ReSharper HeapView Allocation: Object allocation: LINQ method call
(15): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(16): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(17): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(18): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(19): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(20): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(21): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(22): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(23): ReSharper HeapView Allocation: Delegate allocation: capture of 't7' variable
(24): ReSharper HeapView Allocation: Object allocation: LINQ method call
(25): ReSharper HeapView Allocation: Delegate allocation: capture of 'x' parameter
(26): ReSharper HeapView Allocation: Closure allocation: 'i', 'j' variables and 'this' reference
(27): ReSharper HeapView Allocation: Delegate allocation: capture of 'this' reference
(28): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable and 'this' reference
(29): ReSharper HeapView Allocation: Delegate allocation: capture of 'j' variable and 'this' reference
(30): ReSharper HeapView Allocation: Closure allocation: 'i' variable
(31): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(32): ReSharper HeapView Allocation: Closure allocation: 'j' variable
(33): ReSharper HeapView Allocation: Delegate allocation: capture of 'j' variable
(34): ReSharper HeapView Allocation: Closure allocation: 'i', 'j' variables
(35): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(36): ReSharper HeapView Allocation: Delegate allocation: capture of 'j' variable
(37): ReSharper HeapView Allocation: Delegate allocation: capture of 'this' reference
(38): ReSharper HeapView Allocation: Closure allocation: 'i' variable
(39): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' variable
(40): ReSharper HeapView Allocation: Closure allocation: 'a' variable
(41): ReSharper HeapView Allocation: Delegate allocation: capture of 'a' variable
(42): ReSharper HeapView Allocation: Delegate allocation: capture of 'a' variable
(43): ReSharper HeapView Allocation: Closure allocation: 'a' variable
(44): ReSharper HeapView Allocation: Delegate allocation: capture of 'a' variable
(45): ReSharper HeapView Allocation: Delegate allocation: capture of 'a' variable
(46): ReSharper HeapView Allocation: Delegate allocation: capture of 'b' variable
(47): ReSharper HeapView Allocation: Delegate allocation: capture of 'b' variable
(48): ReSharper HeapView Allocation: Closure allocation: 'a' variable
(49): ReSharper HeapView Allocation: Delegate allocation: capture of 'a' variable
(50): ReSharper HeapView Allocation: Closure allocation: 'c', 'd' variables + (outer closure of 'a' variable)
(51): ReSharper HeapView Allocation: Delegate allocation: capture of 'a', 'c' variables
(52): ReSharper HeapView Allocation: Delegate allocation: capture of 'a', 'd' variables
(53): ReSharper HeapView Allocation: Closure allocation: 'b' variable
(54): ReSharper HeapView Allocation: Delegate allocation: capture of 'b' variable
(55): ReSharper HeapView Allocation: Delegate allocation: capture of 'b' variable
(56): ReSharper HeapView Allocation: Closure allocation: 'arg' parameter
(57): ReSharper HeapView Allocation: Delegate allocation: capture of 'arg' parameter
(58): ReSharper HeapView Allocation: Delegate allocation: capture of 'arg' parameter
(59): ReSharper HeapView Allocation: Closure allocation: 'u' parameter + (outer closure of 'arg' parameter)
(60): ReSharper HeapView Allocation: Delegate allocation: capture of 'arg', 'u' parameters
(61): ReSharper HeapView Allocation: Closure allocation: 'i' variable and 'this' reference
(62): ReSharper HeapView Allocation: Closure allocation: 'j' variable + (outer closure of 'i' variable and 'this' reference)
(63): ReSharper HeapView Allocation: Delegate allocation: capture of 'i', 'j' variables and 'this' reference
(64): ReSharper HeapView Allocation: Delegate allocation: capture of 'this' reference
(65): ReSharper HeapView Allocation: Delegate allocation: capture of 'this' reference
(66): ReSharper HeapView Allocation: Delegate allocation: from generic anonymous function (always non cached)
(67): ReSharper HeapView Allocation: Delegate allocation: from generic anonymous function (always non cached)
(68): ReSharper HeapView Allocation: Delegate allocation: from generic anonymous function (always non cached)
(69): ReSharper HeapView Allocation: Delegate allocation: from generic anonymous function (always non cached)
(70): ReSharper HeapView Allocation: Object allocation: transparent identifier anonymous type instantiation
(71): ReSharper HeapView Allocation: Delegate allocation: from generic anonymous function (always non cached)
(72): ReSharper HeapView Allocation: Delegate allocation: from generic anonymous function (always non cached)
(73): ReSharper HeapView Allocation: Delegate allocation: from generic anonymous function (always non cached)
(74): ReSharper HeapView Allocation: Object allocation: transparent identifier anonymous type instantiation
(75): ReSharper HeapView Allocation: Delegate allocation: from generic anonymous function (always non cached)
(76): ReSharper HeapView Allocation: Closure allocation: 'arg' parameter, 'y' variable and 'this' reference
(77): ReSharper HeapView Allocation: Delegate allocation: capture of 'arg' parameter and 'this' reference
(78): ReSharper HeapView Allocation: Delegate allocation: capture of 'y' variable
(79): ReSharper HeapView Allocation: Delegate allocation: capture of 'this' reference
(80): ReSharper HeapView Allocation: Closure allocation: 'value' parameter
(81): ReSharper HeapView Allocation: Delegate allocation: capture of 'value' parameter
(82): ReSharper HeapView Allocation: Closure allocation: 'i' parameter and 'this' reference
(83): ReSharper HeapView Allocation: Closure allocation: 'i' parameter, 'y' variable and 'this' reference
(84): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' parameter and 'this' reference
(85): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' parameter and 'this' reference
(86): ReSharper HeapView Allocation: Delegate allocation: capture of 'i' parameter and 'this' reference
(87): ReSharper HeapView Allocation: Delegate allocation: capture of 'y' variable
(88): ReSharper HeapView Allocation: Closure allocation: 'x' parameter
(89): ReSharper HeapView Allocation: Delegate allocation: capture of 'x' parameter
(90): ReSharper HeapView Allocation: Closure allocation: 'x' parameter
(91): ReSharper HeapView Allocation: Delegate allocation: capture of 'x' parameter
(92): ReSharper HeapView Allocation: Closure allocation: 'y' parameter
(93): ReSharper HeapView Allocation: Delegate allocation: capture of 'y' parameter
(94): ReSharper HeapView Allocation: Delegate allocation: capture of 'x' parameter
(95): ReSharper HeapView Allocation: Closure allocation: 'arg' parameter
(96): ReSharper HeapView Allocation: Object allocation: expression tree construction
(97): ReSharper HeapView Allocation: Object allocation: LINQ method call
(98): ReSharper HeapView Allocation: Object allocation: expression tree construction
(99): ReSharper HeapView Allocation: Object allocation: expression tree construction
(100): ReSharper HeapView Allocation: Object allocation: expression tree construction
(101): ReSharper HeapView Allocation: Closure allocation: 't' parameter + (outer closure of 'arg' parameter)
(102): ReSharper HeapView Allocation: Object allocation: expression tree construction
(103): ReSharper HeapView Allocation: Delegate allocation: capture of 'arg', 't' parameters
(104): ReSharper HeapView Allocation: Object allocation: expression tree construction
